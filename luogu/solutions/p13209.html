<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>博客标题 - Li Qirui的博客</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- Markdown渲染所需的CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.5.1/github-markdown.min.css">

    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#333333',
                        secondary: '#666666',
                        accent: '#4F46E5',
                        light: '#F5F5F5',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                    },
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-balance {
                text-wrap: balance;
            }
            .nav-link {
                position: relative;
            }
            .nav-link::after {
                content: '';
                position: absolute;
                width: 0;
                height: 1px;
                bottom: -2px;
                left: 0;
                background-color: #333333;
                transition: width 0.3s ease;
            }
            .nav-link:hover::after {
                width: 100%;
            }
            .page-transition {
                opacity: 0;
                transform: translateY(20px);
                transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                            transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            }
            .page-visible {
                opacity: 1;
                transform: translateY(0);
            }
            .markdown-body {
                font-size: 1rem;
                line-height: 1.7;
            }
            .blog-image {
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }
            .blog-image:hover {
                transform: translateY(-5px);
                box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            }
        }
    </style>
</head>
<body class="bg-gray-50 text-primary min-h-screen flex flex-col overflow-x-hidden">
    <!-- 主页面容器 -->
    <div id="main-content" class="page-transition w-full">
        <!-- 导航栏 -->
        <header class="w-full border-b border-gray-200 py-6 bg-white sticky top-0 z-10 backdrop-blur-sm bg-opacity-90">
            <nav class="max-w-4xl mx-auto px-6 flex flex-wrap justify-between items-center gap-x-8 gap-y-2 text-secondary">
                <a href="index.html" class="text-lg font-medium text-primary">Li Qirui</a>
                <div class="flex flex-wrap gap-x-8 gap-y-2">
                    <a href="index.html" class="nav-link text-lg font-light transition-colors duration-300 hover:text-primary">HOME</a>
                    <a href="blog.html" class="nav-link text-lg font-light transition-colors duration-300 hover:text-primary text-primary border-b border-primary pb-[2px]">BLOG</a>
                    <a href="luogu.html" class="nav-link text-lg font-light transition-colors duration-300 hover:text-primary">LUOGU</a>
                    <a href="resources.html" class="nav-link text-lg font-light transition-colors duration-300 hover:text-primary">Resources</a>
                </div>
            </nav>
        </header>

        <!-- 博客内容容器 -->
        <main class="max-w-3xl w-full mx-auto px-6 py-12">
            <!-- 博客头部信息 -->
            <div class="mb-12 page-transition">
                <div class="flex items-center text-sm text-secondary mb-4">
                    <span>技术博客</span>
                    <span class="mx-2">•</span>
                    <time datetime="2023-10-15">2025年7月29日</time>
                    <span class="mx-2">•</span>
                    <span>8分钟阅读</span>
                </div>

                <h1 class="text-[clamp(1.8rem,5vw,3rem)] font-light tracking-tight mb-6 leading-tight">
                    题解：P13209 [GCJ 2016 Finals] Map Reduce
                </h1>

                <div class="flex items-center space-x-3 mb-8">
                    <img src="https://picsum.photos/id/1005/40/40" alt="作者头像" class="w-10 h-10 rounded-full object-cover">
                    <div>
                        <p class="text-primary font-medium">Li Qirui</p>
                        <p class="text-xs text-secondary">热衷于编程与技术探索</p>
                    </div>
                </div>

                <div class="w-full h-[300px] md:h-[400px] overflow-hidden rounded-lg mb-8">
                    <img src="https://picsum.photos/id/0/1200/800" alt="博客封面图：题解：P13209 [GCJ 2016 Finals] Map Reduce" class="w-full h-full object-cover blog-image">
                </div>
            </div>

            <!-- 博客正文内容（Markdown风格） -->
            <article class="markdown-body page-transition">
                <h1>题解：P13209 [GCJ 2016 Finals] Map Reduce</h1>
            <p style="font-size: .75em;">
                <a rel="author">lqr2024</a>
                ·
            <time datetime="2025-07-29T23:22:10+08:00">2025-07-29 23:22:10</time>
                ·
            <a href="/article?category=2">题解</a>
            </p>
            <h1>题解：P13209</h1>
            <h3>难度：NOI/NOI+/CTSC</h3>
            <h3>算法：BFS</h3>
            <h3>来源：Luogu - P13209 &lt;- Google Code Jam 2016</h3>
            <h2>题干描述</h2>
            <p>天才游戏设计师 Ben 正在为他即将发布的增强现实手游设计地图。最近，他制作了一张地图，用一个 R 行 C 列的矩阵表示。地图由若干 . 字符（表示空地）、若干 # 字符（表示不可通过的墙）、一个起点 S 和一个终点 F 组成。例如，地图可能如下所示：</p>
            <pre>
                <code>#############
#S..#..##...#
###.##..#.#F#
#...##.##.###
#.#.........#
#############</code>
            </pre>
            <p>在 Ben 的游戏中，一条路径是一系列上下左右的步伐，从一个格子走到另一个格子，且不能经过任何不可通过的墙。</p>
            <p>Ben 认为一张好地图需要满足以下条件：</p>
            <p>任意两个空地（包括起点和终点）之间都存在一条路径。</p>
            <p>为了保证结构完整性，不可通过的墙必须在边上相连，而不能只是通过角相连。对于地图中的任意 2×2 区域，如果该区域恰好有两堵墙，这两堵墙必须在同一行或同一列。换句话说，不能存在如下两种 2×2 区域的墙分布：</p>
            <pre>
                <code>#. .#
.# #.</code>
            </pre>
            <p>地图的边界只能由不可通过的墙组成。一个格子被认为是边界，如果它在最上/最下行，或最左/最右列。</p>
            <p>最短路径长度指的是从起点到终点所需的最少步数。例如，上述例子的最短路径长度为 17 步。</p>
            <p>作为如此聪明的制图者，Ben 发现他设计的这张地图对朋友们来说太难了。他希望通过移除一些不可通过的墙来降低难度。具体来说，他想知道是否可以移除零个或若干墙，使得从起点到终点的最短路径恰好为 D 步，并且修改后的地图依然是好地图。注意，仅仅找到一条长度为 D 的路径是不够的，D 必须是最短路径长度。</p>
            <p>例如，如果 D=15，我们可以移除终点正下方的一堵墙，得到一个合法解：</p>
            <pre>
                <code>#############
#S..#..##...#
###.##..#.#F#
#...##.##.#.#
#.#.........#
#############</code>
            </pre>
            <p>如果 D=5，则没有解。</p>
            <h2>基本可行性检查</h2>
            <ul>
                <li>
                    <p>
                        <strong>曼哈顿距离</strong>
                        ：S到F的直线最短距离（上下左右移动的理论最小值），D不能小于此值。
                    </p>
                </li>
                <li>
                    <p>
                        <strong>当前最短路径</strong>
                        ：原始地图中S到F的最短路径（通过 BFS 计算），D不能大于此值（移除墙只会缩短或保持最短路径）。
                    </p>
                </li>
                <li>
                    <p>
                        <strong>奇偶性一致</strong>
                        ：S到F的路径长度奇偶性由其坐标决定（每步改变坐标和的奇偶性），故D必须与min_d、curr_d同奇偶（即 <la-tex display="inline">(curr_d−D) \bmod 2=0 </la-tex>
                        ）。
                    </p>
                </li>
            </ul>
            <p>
                <strong>若不满足上述条件，直接返回IMPOSSIBLE。</strong>
            </p>
            <h2>确定可安全移除的墙</h2>
            <ul>
                <li>
                    <p>墙不在边界（边界必须是墙）。</p>
                </li>
                <li>
                    <p>移除后不形成 invalid 的 2×2 区域（对角线分布的两堵墙）。</p>
                </li>
                <li>
                    <p>相邻墙的数量和位置符合结构完整性（避免孤立墙或不合理连接）。</p>
                </li>
                <li>
                    <p>通过 BFS 扩展可移除墙列表：移除一个墙后，检查其 8 邻域的墙是否变为可移除，逐步生成所有可移除墙。</p>
                </li>
            </ul>
            <h2>二分搜索最优移除方案</h2>
            <ul>
                <li>对可移除墙列表，二分尝试移除前l个墙，检查最短路径是否≥D。</li>
                <li>找到最大的l，使移除后最短路径≥D，再验证是否恰好为D。</li>
            </ul>
            <p>题目思路讲解完毕，上硬通货，代码！AC</p>
            <pre>
                <code class="language-cpp">#include &lt;bits/stdc++.h &gt;using namespace std;

typedef pair &lt;int, int &gt;pii;
const int dx[] = {-1,0,1,0,-1,1,1,-1};
const int dy[] = {0,1,0,-1,1,1,-1,-1};

int manh_dist(pii S, pii F) {
    return abs(S.first-F.first) + abs(S.second-F.second);
}

int shrt_dist(const vector &lt;vector &lt;char &gt;&gt;&amp;M, pii S, pii F, int R, int C) {
    vector &lt;vector &lt;int &gt;&gt;d(R, vector &lt;int &gt;(C, -1));
    deque &lt;pii &gt;q;
    q.push_back(S);
    d[S.first][S.second] = 0;
    while (!q.empty()) {
        auto [r,c] = q.front(); q.pop_front();
        if (r == F.first &amp;&amp;c == F.second) return d[r][c];
        for (int i=0;i &lt;4;i++) {
            int nr = r + dx[i], nc = c + dy[i];
            if (nr &gt;=0 &amp;&amp;nr &lt;R &amp;&amp;nc &gt;=0 &amp;&amp;nc &lt;C &amp;&amp;M[nr][nc]!='#'&amp;&amp;d[nr][nc]==-1) {
                d[nr][nc] = d[r][c]+1;
                q.push_back({nr, nc});
            }
        }
    }
    assert(0);
}

bool can_rm(const vector &lt;vector &lt;char &gt;&gt;&amp;M, pii p, int R, int C) {
    int r = p.first, c = p.second;
    if (r &lt;=0||r &gt;=R-1||c &lt;=0||c &gt;=C-1) return 0;
    if (M[r][c]!='#') return 0;
    if (M[r-1][c-1]!='#'&amp;&amp;M[r-1][c]=='#'&amp;&amp;M[r][c-1]=='#') return 0;
    if (M[r-1][c+1]!='#'&amp;&amp;M[r-1][c]=='#'&amp;&amp;M[r][c+1]=='#') return 0;
    if (M[r+1][c-1]!='#'&amp;&amp;M[r+1][c]=='#'&amp;&amp;M[r][c-1]=='#') return 0;
    if (M[r+1][c+1]!='#'&amp;&amp;M[r+1][c]=='#'&amp;&amp;M[r][c+1]=='#') return 0;
    int cnt=0, pr=0;
    for (int i=0;i &lt;4;i++) {
        int nr = r+dx[i], nc = c+dy[i];
        if (M[nr][nc]=='#') { cnt++; pr ^= i; }
    }
    return cnt==0||cnt==1||(cnt==2 &amp;&amp;(pr &amp;1));
}

vector &lt;pii &gt;find_rm_list(vector &lt;vector &lt;char &gt;&gt;&amp;M, pii S, pii F, int R, int C) {
    vector &lt;pii &gt;rm;
    deque &lt;pii &gt;q;
    set &lt;pii &gt;vis;
    for (int r=0;r &lt;R;r++) for (int c=0;c &lt;C;c++) {
        if (can_rm(M, {r,c}, R, C)) { vis.insert({r,c}); q.push_back({r,c}); }
    }
    while (!q.empty()) {
        auto [r,c] = q.front(); q.pop_front();
        if (!can_rm(M, {r,c}, R, C)) { vis.erase({r,c}); continue; }
        rm.push_back({r,c});
        M[r][c] = '.';
        for (int i=0;i &lt;8;i++) {
            int nr = r+dx[i], nc = c+dy[i];
            pii p={nr,nc};
            if (nr &gt;=0 &amp;&amp;nr &lt;R &amp;&amp;nc &gt;=0 &amp;&amp;nc &lt;C &amp;&amp;can_rm(M,p,R,C)&amp;&amp;!vis.count(p)) {
                vis.insert(p); q.push_back(p);
            }
        }
    }
    return rm;
}

void apply_rm(vector &lt;vector &lt;char &gt;&gt;&amp;M, const vector &lt;pii &gt;&amp;rm, int l) {
    for (int i=0;i &lt;rm.size();i++) {
        auto [r,c] = rm[i];
        M[r][c] = (i &lt;l)?'.':'#';
    }
}

int bin_search(vector &lt;vector &lt;char &gt;&gt;&amp;M, pii S, pii F, int D, const vector &lt;pii &gt;&amp;rm, int R, int C) {
    int l=0, r=rm.size(), res=0;
    while (l &lt;=r) {
        int m=l+(r-l)/2;
        apply_rm(M, rm, m);
        if (shrt_dist(M, S, F, R, C)&gt;=D) { res=m; l=m+1; }
        else r=m-1;
    }
    return res;
}

bool is_inv(const vector &lt;vector &lt;char &gt;&gt;&amp;M, pii p, int R, int C) {
    int r=p.first, c=p.second;
    if (r &gt;=R-1||c &gt;=C-1) return 0;
    if (M[r][c]=='#'&amp;&amp;M[r+1][c+1]=='#'&amp;&amp;M[r][c+1]!='#'&amp;&amp;M[r+1][c]!='#') return 1;
    if (M[r][c+1]=='#'&amp;&amp;M[r+1][c]=='#'&amp;&amp;M[r][c]!='#'&amp;&amp;M[r+1][c+1]!='#') return 1;
    return 0;
}

bool check(const vector &lt;vector &lt;char &gt;&gt;&amp;M, pii S, pii F, int D, int R, int C) {
    for (int r=0;r &lt;R;r++) for (int c=0;c &lt;C;c++) if (is_inv(M, {r,c}, R, C)) return 0;
    return shrt_dist(M, S, F, R, C)==D;
}

string solve() {
    int R,C,D; cin &gt;&gt;R &gt;&gt;C &gt;&gt;D;
    vector &lt;vector &lt;char &gt;&gt;M(R);
    pii S,F;
    for (int r=0;r &lt;R;r++) {
        string s; cin &gt;&gt;s; M[r] = vector &lt;char &gt;(s.begin(), s.end());
        for (int c=0;c &lt;C;c++) {
            if (M[r][c]=='S') { S={r,c}; M[r][c]='.'; }
            else if (M[r][c]=='F') { F={r,c}; M[r][c]='.'; }
        }
    }
    int min_d=manh_dist(S,F), curr_d=shrt_dist(M,S,F,R,C);
    if (!(min_d &lt;=D &amp;&amp;D &lt;=curr_d &amp;&amp;(curr_d-D)%2==0)) return "IMPOSSIBLE";
    auto rm=find_rm_list(M, S, F, R, C);
    int l=bin_search(M, S, F, D, rm, R, C);
    apply_rm(M, rm, l);
    if (!check(M, S, F, D, R, C)) assert(0);
    M[S.first][S.second]='S'; M[F.first][F.second]='F';
    string res="POSSIBLE\n";
    for (int r=0;r &lt;R;r++) { res+=string(M[r].begin(), M[r].end())+"\n"; }
    res.pop_back();
    return res;
}

int main() {
    int T; cin &gt;&gt;T;
    for (int t=1;t &lt;=T;t++) {
        cout &lt;&lt;"Case #"&lt;&lt;t &lt;&lt;": "&lt;&lt;solve()&lt;&lt;endl;
    }
    return 0;
}</code>
            </pre>
            </article>

            <!-- 标签区域 -->
            <div class="mt-16 mb-12 flex flex-wrap gap-3 page-transition">
                <span class="text-secondary">标签：</span>
                <a href="#" class="px-3 py-1 bg-light text-primary rounded-full text-sm hover:bg-gray-200 transition-colors duration-300">Markdown</a>
                <a href="#" class="px-3 py-1 bg-light text-primary rounded-full text-sm hover:bg-gray-200 transition-colors duration-300">写作</a>
                <a href="#" class="px-3 py-1 bg-light text-primary rounded-full text-sm hover:bg-gray-200 transition-colors duration-300">语法</a>
                <a href="#" class="px-3 py-1 bg-light text-primary rounded-full text-sm hover:bg-gray-200 transition-colors duration-300">教程</a>
            </div>

            <!-- 分享区域 -->
            <div class="mt-12 mb-16 flex items-center justify-between border-t border-b border-gray-200 py-6 page-transition">
                <div class="text-secondary">分享本文：</div>
                <div class="flex gap-4">
                    <a href="#" class="w-10 h-10 rounded-full bg-light flex items-center justify-center text-secondary hover:bg-primary hover:text-white transition-all duration-300">
                        <i class="fa fa-twitter"></i>
                    </a>
                    <a href="#" class="w-10 h-10 rounded-full bg-light flex items-center justify-center text-secondary hover:bg-primary hover:text-white transition-all duration-300">
                        <i class="fa fa-facebook"></i>
                    </a>
                    <a href="#" class="w-10 h-10 rounded-full bg-light flex items-center justify-center text-secondary hover:bg-primary hover:text-white transition-all duration-300">
                        <i class="fa fa-linkedin"></i>
                    </a>
                    <a href="#" class="w-10 h-10 rounded-full bg-light flex items-center justify-center text-secondary hover:bg-primary hover:text-white transition-all duration-300">
                        <i class="fa fa-envelope"></i>
                    </a>
                </div>
            </div>
        </main>

        <!-- 页脚 -->
        <footer class="bg-white border-t border-gray-200 mt-20">
            <div class="max-w-4xl mx-auto px-6 py-12">
                <div class="flex flex-col md:flex-row justify-between items-center gap-6">
                    <div class="text-center md:text-left">
                        <h3 class="text-lg font-medium mb-2">Li Qirui</h3>
                        <p class="text-secondary text-sm">热衷于编程与技术探索</p>
                    </div>

                    <div class="flex space-x-6">
                        <a href="#" class="text-secondary hover:text-primary transition-colors duration-300">
                            <i class="fa fa-github text-xl"></i>
                        </a>
                        <a href="#" class="text-secondary hover:text-primary transition-colors duration-300">
                            <i class="fa fa-linkedin text-xl"></i>
                        </a>
                        <a href="#" class="text-secondary hover:text-primary transition-colors duration-300">
                            <i class="fa fa-envelope text-xl"></i>
                        </a>
                    </div>
                </div>

                <div class="mt-10 pt-6 border-t border-gray-100 text-center text-xs text-gray-400">
                    &copy; <span id="currentYear"></span> Li Qirui. All rights reserved.
                </div>
            </div>
        </footer>
    </div>

    <!-- 回到顶部按钮 -->
    <button id="backToTop" class="fixed bottom-8 right-8 w-12 h-12 rounded-full bg-primary text-white flex items-center justify-center shadow-lg opacity-0 invisible transition-all duration-300 hover:bg-opacity-90">
        <i class="fa fa-arrow-up"></i>
    </button>

    <script>
        // 设置当前年份
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        // 页面滚动效果
        const backToTopBtn = document.getElementById('backToTop');

        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTopBtn.classList.remove('opacity-0', 'invisible');
                backToTopBtn.classList.add('opacity-100', 'visible');
            } else {
                backToTopBtn.classList.remove('opacity-100', 'visible');
                backToTopBtn.classList.add('opacity-0', 'invisible');
            }
        });

        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // 滚动动画 - 元素进入视口时显示
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.1
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('page-visible');
                    observer.unobserve(entry.target);
                }
            });
        }, observerOptions);

        // 监听所有需要动画的元素
        document.querySelectorAll('.page-transition').forEach(el => {
            observer.observe(el);
        });

        // 二进制序列监听功能（与主页保持一致）
        const targetSequence = "01000111010000010100110101000101"; // "GAME"的二进制表示
        let currentSequence = "";
        const maxSequenceLength = targetSequence.length;

        document.addEventListener('keydown', (e) => {
            if (e.key === '0' || e.key === '1') {
                currentSequence += e.key;

                if (currentSequence.length > maxSequenceLength) {
                    currentSequence = currentSequence.slice(1);
                }

                if (currentSequence === targetSequence) {
                    navigateToGame();
                    resetSequence();
                }
            } else {
                resetSequence();
            }
        });

        function resetSequence() {
            currentSequence = "";
        }

        function navigateToGame() {
            // 创建过渡层
            const transitionOverlay = document.createElement('div');
            transitionOverlay.id = 'transition-overlay';
            transitionOverlay.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-500';
            transitionOverlay.innerHTML = `
                <div class="text-white text-center">
                    <div class="w-16 h-16 border-4 border-white border-t-accent rounded-full animate-spin mx-auto mb-4"></div>
                    <p>正在加载游戏...</p>
                </div>
            `;
            document.body.appendChild(transitionOverlay);

            // 触发过渡动画
            setTimeout(() => {
                transitionOverlay.classList.remove('opacity-0', 'pointer-events-none');
                transitionOverlay.classList.add('opacity-100', 'pointer-events-auto');

                setTimeout(() => {
                    window.location.href = 'game/01.html';
                }, 800);
            }, 100);
        }
    </script>
</body>
</html>
